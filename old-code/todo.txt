



// Homekit is 0-100 brightness. This endpoint takes a 0-100 value.
  // In the future we should probably make this consistent so the app sends
  // 0-100 as well. Audrey's hexagon is the holdout!

  // void handleHomekitBrightness() {
  //   String brightness_submitted = server.arg("brightness");
  //   if (brightness_submitted.length() > 0) {
  //     int brightness = (int)((float)brightness_submitted.toInt() / 100 * 255);
  //     Soulmate.setBrightness(brightness);
  //   }

  //   int b = Soulmate.brightness;
  //   int brightnessOutOfAHundred = (float)b / 255 * 100;
  //   String brightness = String(brightnessOutOfAHundred);
  //   sendStatus();
  // }

  // // HTTP webserver
  // void setupServer() {
  //   server.on("/", sendStatus);

  //   // App endpoints
  //   server.on("/list", sendStatus);
  //   server.on("/choose", []() {
  //     String routine = server.arg("routine");
  //     if (routine == "") {
  //       server.send(404, "text/plain", "404");
  //       return;
  //     }
  //     Soulmate.chooseRoutine(routine.toInt());
  //     sendStatus();
  //   });
  //   server.on("/name", []() {
  //     Soulmate.setName(server.arg("name"));
  //     sendStatus();
  //   });
  //   server.on("/brightness", []() {
  //     String b = server.arg("brightness");
  //     if (b.length() > 0) {
  //       Soulmate.setBrightness((int)b.toInt());
  //     }
  //     sendStatus();
  //   });
  //   server.on("/update", []() {
  //     t_httpUpdate_return ret = updateFirmware();
  //     switch (ret) {
  //       case HTTP_UPDATE_FAILED:
  //         server.send(200, "text/plain", "Update failed: " + ESPhttpUpdate.getLastErrorString());
  //         break;
  //       case HTTP_UPDATE_NO_UPDATES:
  //         server.send(200, "text/plain", "No update available.");
  //         break;
  //       case HTTP_UPDATE_OK:
  //         server.send(200, "text/plain", "Updating firmware, please wait...");
  //         ESP.restart();
  //         break;
  //       default:
  //         server.send(200, "text/plan", "Something else happened: " + ret);
  //         break;
  //     }
  //   });
  //   server.on("/reset", []() {
  //     server.send(200, "text/plain", "See ya later!");
  //     resetWifiSettings();
  //   });
  //   server.onNotFound([]() {
  //     server.send(404, "text/plain", "404");
  //   });
  //   server.on("/on", []() {
  //     Soulmate.turnOn();
  //     server.send(200, "text/plain", "on");
  //   });
  //   server.on("/off", []() {
  //     Soulmate.turnOff();
  //     server.send(200, "text/plain", "off");
  //   });

  //   // HomeBridge
  //   server.on("/homebridge/brightness", handleHomekitBrightness);
  //   server.on("/homebridge/on", []() {
  //     Soulmate.turnOn();
  //     server.send(200, "text/plain", "on");
  //   });
  //   server.on("/homebridge/off", []() {
  //     Soulmate.turnOff();
  //     server.send(200, "text/plain", "off");
  //   });

  //   server.begin();
  //   Serial.println("Soulmate HTTP server started");
  // }

















    // WiFi.persistent(false);
  // WiFi.mode(WIFI_OFF);   // this is a temporary line, to be removed after SDK update to 1.5.4
  // WiFi.mode(WIFI_STA);
  // WiFi.persistent(true);
  // WiFi.begin(ssid, pass);

  // unsigned long start = millis();
  // boolean keepConnecting = true;
  // uint8_t status;
  // while (keepConnecting) {
  //   status = WiFi.status();
  //   if (millis() > start + _connectTimeout) {
  //     keepConnecting = false;
  //     Serial.println("Connection timed out");
  //   }
  //   if (status == WL_CONNECTED || status == WL_CONNECT_FAILED) {
  //     keepConnecting = false;
  //   }
  //   delay(100);
  // }

  // if (status == WL_CONNECTED) {
  //   // delay(1000);
  //   ESP.restart();
  // }


  //     if (root.containsKey("update")) {
      //       #ifndef FIRMWARE_NAME
      //         simpleWebsocketSend("update", "Auto-update isn't available for this Soulmate.");
      //         return;
      //       #endif

      //       t_httpUpdate_return ret = updateFirmware();
      //       switch (ret) {
      //         case HTTP_UPDATE_FAILED:
      //           Serial.printf("HTTP_UPDATE_FAILED Error (%d): %s", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
      //           Serial.println("");
      //           // simpleWebsocketSend("update", "Update Failed");
      //           break;
      //         case HTTP_UPDATE_NO_UPDATES:
      //           Serial.println("No updates");
      //           // simpleWebsocketSend("update", "No updates available.");
      //           break;
      //         case HTTP_UPDATE_OK:
      //           ESP.restart();
      //           break;
      //         default:
      //           Serial.println("Something else happened with the update.");
      //           break;
      //         }
      //     }
      //     if (root.containsKey("reset")) {
      //       resetWifiSettings();
      //     }

      //     updateWifiClients();
      //   }
      //   break;
      // case WStype_CONNECTED:
      //   Serial.println("Websocket connected!");
      //   break;
      // case WStype_DISCONNECTED:
      //   Serial.println("Websocket disconnected!");
      //   break;
      // default:
      //   Serial.println("Another WStype: " + type);
      //   break;
    // }

    // void simpleWebsocketSend(String key, String value) {
  //   // DynamicJsonBuffer jsonBuffer;
  //   // JsonObject& message = jsonBuffer.createObject();
  //   // message[key] = value;
  //   // String status;
  //   // message.printTo(status);
  //   // webSocket.broadcastTXT(status.c_str(), status.length());
  // }

  // void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
    // switch(type) {
    //   case WStype_TEXT:
    //     {
    //       StaticJsonBuffer<200> jsonBuffer;
    //       JsonObject& root = jsonBuffer.parseObject(payload);

    //       Soulmate.consumeJson(root);

    //       if (root.containsKey("update")) {
    //         #ifndef FIRMWARE_NAME
    //           simpleWebsocketSend("update", "Auto-update isn't available for this Soulmate.");
    //           return;
    //         #endif

    //         t_httpUpdate_return ret = updateFirmware();
    //         switch (ret) {
    //           case HTTP_UPDATE_FAILED:
    //             Serial.printf("HTTP_UPDATE_FAILED Error (%d): %s", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
    //             Serial.println("");
    //             // simpleWebsocketSend("update", "Update Failed");
    //             break;
    //           case HTTP_UPDATE_NO_UPDATES:
    //             Serial.println("No updates");
    //             // simpleWebsocketSend("update", "No updates available.");
    //             break;
    //           case HTTP_UPDATE_OK:
    //             ESP.restart();
    //             break;
    //           default:
    //             Serial.println("Something else happened with the update.");
    //             break;
    //           }
    //       }
    //       if (root.containsKey("reset")) {
    //         resetWifiSettings();
    //       }

    //       updateWifiClients();
    //     }
    //     break;
    //   case WStype_CONNECTED:
    //     Serial.println("Websocket connected!");
    //     break;
    //   case WStype_DISCONNECTED:
    //     Serial.println("Websocket disconnected!");
    //     break;
    //   default:
    //     Serial.println("Another WStype: " + type);
    //     break;
    // }
  // }




// TaskHandle_t LEDTask;

// void PrintLEDs(void * parameter) {
//   for (;;) {
//     Soulmate.showPixels();
//     EVERY_N_SECONDS(1) {
//       String taskMessage = "LED Task running on core ";
//       taskMessage = taskMessage + xPortGetCoreID();
//       Serial.println(taskMessage);
//     }
//   }
// }
  // xTaskCreatePinnedToCore(PrintLEDs, "LEDTask", 10000, NULL, 0, &LEDTask, tskNO_AFFINITY);
