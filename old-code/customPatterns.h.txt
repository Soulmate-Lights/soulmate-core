// #ifdef ENABLE_CUSTOM_PATTERNS
//   if (root.containsKey("customRoutine")) {
//     const char *data = root["customRoutine"].as<char*>();
//     saveRoutine(data);
//   }
// #endif

// #ifdef ENABLE_CUSTOM_PATTERNS
// CRGB previousBlendedFrame[N_LEDS];
// CRGB nextBlendedFrame[N_LEDS];
// #endif

// void playCustomRoutine() {
//   #ifdef ENABLE_CUSTOM_PATTERNS
//     int customRoutineIndex = Soulmate.currentRoutine - Soulmate.numberOfFixedRoutines;
//     CustomRoutine routine = Soulmate.routineData[customRoutineIndex];

//     // routine.step();
//     // for (int i = 0; i < N_LEDS; i++) {
//     //   int pixel = routine.frames[routine.frame][i];
//     //   Soulmate.led_arr[i] = CHSV(pixel, 255, 255);
//     // }

//     if (routine.step()) {
//       for (int i = 0; i < N_LEDS; i++) {
//         previousBlendedFrame[i] = Soulmate.led_arr[i];
//         int pixel = routine.frames[routine.frame][i];
//         // Soulmate.led_arr[i] = CHSV(pixel, 255, 255);
//         if (pixel == -1 || pixel == 1) {
//           nextBlendedFrame[i] = CRGB::Black;
//         } else {
//           nextBlendedFrame[i] = CHSV(pixel, 255, 255);
//         }
//       }
//     } else {
//       int percentage = routine.blendPercentage8();
//       for (int i = 0; i < N_LEDS; i++) {
//         // CRGB pixel = blend(CRGB::Black, previousBlendedFrame[i], 255 - percentage);
//         // pixel = blend(pixel, nextBlendedFrame[i], percentage);
//         CRGB pixel = blend(previousBlendedFrame[i], nextBlendedFrame[i], percentage);
//         Soulmate.led_arr[i] = pixel;
//       }
//     }
//     Soulmate.routineData[customRoutineIndex] = routine;
//   #endif
// }

// #ifdef ENABLE_CUSTOM_PATTERNS
//   int numberOfFixedRoutines = 0;
//   int customRoutineCount = 0;
//   // Save a new routine (from phone)
//   void saveRoutine(const char* framesString) {

//     String currentNumber = "";
//     CRGB frame[N_LEDS];
//     int frameNumber = 0;
//     int pixelNumber = 0;
//     CustomRoutine customRoutine;
//     customRoutine.frame = 0;

//     bool gotTime = false;
//     String timeString = "";
//     uint16_t timeInteger = 1000;

//     for (int i = 0; i < strlen(framesString) + 1; i++) {
//       if (!gotTime) {
//         if (framesString[i] == ':') {
//           gotTime = true;
//           timeInteger = timeString.toInt();
//         } else {
//           timeString += String(framesString[i]);
//         }
//       } else {
//         if (framesString[i] == ',') {
//           int pixel = pixelNumber % N_LEDS;

//           if (currentNumber == "-1") {
//             currentNumber = "1";
//           }

//           customRoutine.frames[frameNumber][pixel] = currentNumber.toInt();
//           currentNumber = "";
//           pixelNumber++;
//           if (pixelNumber > 0 && pixelNumber % N_LEDS == 0) {
//             frameNumber++;
//           }
//         } else {
//           currentNumber += String(framesString[i]);
//         }
//       }
//     }

//     // Serial.println(frameNumber);
//     // Serial.println((String) customRoutine);

//     customRoutine.numberOfFrames = frameNumber;
//     routines[routineCount] = playCustomRoutine;
//     String name = "Custom pattern";
//     routineNames[routineCount] = name;
//     customRoutine.frameTime = timeInteger;
//     routineData[customRoutineCount] = customRoutine;
//     chooseRoutineAndSaveLater(routineCount);
//     if (customRoutineCount == 0) {
//       customRoutineCount++;
//       routineCount++;
//     }
//   }

//   void chooseRoutineAndSaveLater(int i) {
//     previousRoutine = currentRoutine;
//     fadeStart = millis();
//     currentRoutine = i;
//     // needsSave = true;
//   }
//   #endif

// #ifdef ENABLE_CUSTOM_PATTERNS
//   #import "./CustomRoutine.h"
// #endif

// #ifdef ENABLE_CUSTOM_PATTERNS
//   numberOfFixedRoutines = routineCount;
// #endif




// TODO(elliott): HTTP version of custom routines
    // server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) {
    //   if (request->url() == "/newRoutine") {
    //     // const char* data = ????????????????????
    //     // Soulmate.saveRoutine((char*) data);
    //     request->send(200, "text/plain", "end");
    //   }
    // });

// Custom patterns:
// TODO(elliott): We may be able to reinstate these custom patterns once we have larger data
// #ifdef ENABLE_CUSTOM_PATTERNS
//   uint8_t payload[8000];
// #else
//   uint8_t payload[100];
// #endif
// for (int i = 0; i < len; ++i) {
  //   payload[info->index + i] = data[i];
  // }


// // OTA updates from a hosted firmware image on the server
//   void handleUpdate() {
//     Serial.println("Updating, please wait...");

//     #ifdef FIRMWARE_NAME
//       String url = String("http://soulmate-firmwares.herokuapp.com/") + FIRMWARE_NAME + String(".ino.bin?version=") + SOULMATE_VERSION;

//       // ESPhttpUpdate.rebootOnUpdate(false); // todo(elliott): determine whether this makes restarts after firmware updates faster?
//       // t_httpUpdate_return ret = ESPhttpUpdate.update(url);
//       // switch(ret) {
//       //   case HTTP_UPDATE_FAILED:
//       //     // server.send(200, "text/plain", "Update failed: " + ESPhttpUpdate.getLastErrorString());
//       //     Serial.printf("HTTP_UPDATE_FAILED Error (%d): %s", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
//       //     break;
//       //   case HTTP_UPDATE_NO_UPDATES:
//       //     // server.send(200, "text/plain", "No update available.");
//       //     Serial.println("HTTP_UPDATE_NO_UPDATES");
//       //     break;
//       //   case HTTP_UPDATE_OK:
//       //     // server.send(200, "text/plain", "Updating firmware, please wait...");
//       //     Serial.println("HTTP_UPDATE_OK");
//       //     ESP.restart();
//       //     break;
//       //   default:
//       //     Serial.println(ret);
//       //     // server.send(200, "text/plan", "Something else happened");
//       //     break;
//       // }
//     #else
//       // server.send(200, "text/plain", "Sorry, firmware updates aren't available.");
//     #endif
//   }

// Copyright 2019 Soulmate Lighting, LLC

#ifndef BUILDER_LIBRARIES_SOULMATE_CUSTOMROUTINE_H_
#define BUILDER_LIBRARIES_SOULMATE_CUSTOMROUTINE_H_

void playCustomRoutine();

class CustomRoutine {
 public:
  String name;
  byte frames[60][37];
  int numberOfFrames;
  int frame = 0;
  bool forwards = true;

  double frameTime;
  double frameStart = millis() - 3000;

  int blendPercentage8() {
    int64_t duration = millis() - frameStart;
    double percentage = duration / frameTime;
    return percentage * 255;
  }

  bool step() {
    if (millis() > frameStart + frameTime) {
      frameStart = millis();
      if (numberOfFrames > 1) {
        forwards ? frame++ : frame--;
        if (frame == numberOfFrames) {
          frame = numberOfFrames - 1;
          forwards = false;
          frameStart -= frameTime / 2;
        }
        if (frame == -1) {
          frame = 0;
          forwards = true;
          frameStart -= frameTime / 2;
        }
      }
      return true;
    }
    return false;
  }
};

#endif  // BUILDER_LIBRARIES_SOULMATE_CUSTOMROUTINE_H_


#ifdef ENABLE_CUSTOM_PATTERNS
    server.onRequestBody([](AsyncWebServerRequest * request, uint8_t *data, size_t len, size_t index, size_t total) {
      if (request->url() == "/newRoutine") {
        Soulmate.saveRoutine(reinterpret_cast<char*>(data));
        request->send(200, "text/plain", "end");
      }
    });
    #endif