// Copyright 2019 Soulmate Lighting, LLC

#ifdef ESP8266
#ifndef SOULMATE_WIFI
#define SOULMATE_WIFI

#include <DNSServer.h>
#include <WiFiManager.h>
#include <ArduinoJson.h>
#include <ESP8266WiFi.h>
#include <ESP8266WebServer.h>
#include <ESP8266mDNS.h>
#include <ESP8266httpUpdate.h>
// TODO(elliott): Async websockets
// #define WEBSOCKETS_NETWORK_TYPE NETWORK_ESP8266_ASYNC
// #include <ESPAsyncTCP.h>
#include <WebSocketsServer.h>

ESP8266WebServer server(80);
WebSocketsServer webSocket = WebSocketsServer(81);
WiFiManager wifiManager;
String _updaterError;

// Wifi class - handles all WiFi config and firmware updates
namespace Wifi {

  unsigned long lastBroadcast = millis();

  void updateWifiClients() {
    if (millis() - lastBroadcast < 1000) return;
    String s = Soulmate.status();
    webSocket.broadcastTXT(s.c_str(), s.length());
    lastBroadcast = millis();
  }

  t_httpUpdate_return updateFirmware() {
    #ifdef FIRMWARE_NAME
      String url = String("http://soulmate-firmwares.herokuapp.com/") + FIRMWARE_NAME + String("-ESP8266.ino.bin?version=") + SOULMATE_VERSION;
      // ESPhttpUpdate.rebootOnUpdate(false); // todo(elliott): determine whether this makes restarts after firmware updates faster?
      t_httpUpdate_return ret = ESPhttpUpdate.update(url);
      return ret;
    #endif
  }

  void handleUpdate() {
    Serial.println("Updating, please wait...");

    #ifdef FIRMWARE_NAME
      t_httpUpdate_return ret = updateFirmware();
      switch(ret) {
        case HTTP_UPDATE_FAILED:
          server.send(200, "text/plain", "Update failed: " + ESPhttpUpdate.getLastErrorString());
          Serial.printf("HTTP_UPDATE_FAILED Error (%d): %s", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
          break;
        case HTTP_UPDATE_NO_UPDATES:
          server.send(200, "text/plain", "No update available.");
          Serial.println("HTTP_UPDATE_NO_UPDATES");
          break;
        case HTTP_UPDATE_OK:
          server.send(200, "text/plain", "Updating firmware, please wait...");
          Serial.println("HTTP_UPDATE_OK");
          ESP.restart();
          break;
        default:
          Serial.println(ret);
          server.send(200, "text/plan", "Something else happened");
          break;
      }
    #else
      server.send(200, "text/plain", "Sorry, firmware updates aren't available.");
    #endif
  }

  void resetWifiSettings() {
    Serial.println("resetWifiSettings");
    // delay(1000);
    wifiManager.resetSettings();
    ESP.restart();
  }

  void simpleWebsocketSend(String key, String value) {
    StaticJsonBuffer<200> jsonBuffer;
    JsonObject& message = jsonBuffer.createObject();
    message[key] = value;
    String status;
    message.printTo(status);
    webSocket.broadcastTXT(status.c_str(), status.length());
  }

  void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {
    switch(type) {
      case WStype_TEXT:
        {
          StaticJsonBuffer<200> jsonBuffer;
          JsonObject& root = jsonBuffer.parseObject(payload);

          Soulmate.consumeJson(root);

          if (root.containsKey("update")) {
            #ifndef FIRMWARE_NAME
              simpleWebsocketSend("update", "Auto-update isn't available for this Soulmate.");
              return;
            #endif

            t_httpUpdate_return ret = updateFirmware();
            switch (ret) {
              case HTTP_UPDATE_FAILED:
                Serial.printf("HTTP_UPDATE_FAILED Error (%d): %s", ESPhttpUpdate.getLastError(), ESPhttpUpdate.getLastErrorString().c_str());
                Serial.println("");
                // simpleWebsocketSend("update", "Update Failed");
                break;
              case HTTP_UPDATE_NO_UPDATES:
                Serial.println("No updates");
                // simpleWebsocketSend("update", "No updates available.");
                break;
              case HTTP_UPDATE_OK:
                ESP.restart();
                break;
              default:
                Serial.println("Something else happened with the update.");
                break;
              }
          }
          if (root.containsKey("reset")) {
            resetWifiSettings();
          }

          updateWifiClients();
        }
        break;
      case WStype_CONNECTED:
        Serial.println("Websocket connected!");
        break;
      case WStype_DISCONNECTED:
        Serial.println("Websocket disconnected!");
        break;
      default:
        Serial.println("Another WStype: " + type);
        break;
    }
  }

  void sendStatus() {
    server.send(200, "application/json", Soulmate.status());
  }

  // DNS
  void startMDNS() {
    String name = String("soulmate-" + WiFi.macAddress());
    name.replace(":", "");
    char copy[50];
    name.toCharArray(copy, 50);

    if (MDNS.begin(copy)) {
      MDNS.addService("http", "tcp", 80);
    }
  }

  // Homekit is 0-100 brightness. This endpoint takes a 0-100 value.
  // In the future we should probably make this consistent so the app sends
  // 0-100 as well. Audrey's hexagon is the holdout!
  void handleHomekitBrightness() {
    String brightness_submitted = server.arg("brightness");
    if (brightness_submitted.length() > 0) {
      int brightness = (int)((float)brightness_submitted.toInt() / 100 * 255);
      Soulmate.setBrightness(brightness);
    }

    int b = Soulmate.brightness;
    int brightnessOutOfAHundred = (float)b / 255 * 100;
    String brightness = String(brightnessOutOfAHundred);
    sendStatus();
  }

  // HTTP webserver
  void setupServer() {
    server.on("/", sendStatus);

    // App endpoints
    server.on("/list", sendStatus);
    server.on("/choose", []() {
      String routine = server.arg("routine");
      if (routine == "") {
        server.send(404, "text/plain", "404");
        return;
      }
      Soulmate.chooseRoutine(routine.toInt());
      sendStatus();
    });
    server.on("/name", []() {
      Soulmate.setName(server.arg("name"));
      sendStatus();
    });
    server.on("/brightness", []() {
      String b = server.arg("brightness");
      if (b.length() > 0) {
        Soulmate.setBrightness((int)b.toInt());
      }
      sendStatus();
    });
    server.on("/update", []() {
      t_httpUpdate_return ret = updateFirmware();
      switch (ret) {
        case HTTP_UPDATE_FAILED:
          server.send(200, "text/plain", "Update failed: " + ESPhttpUpdate.getLastErrorString());
          break;
        case HTTP_UPDATE_NO_UPDATES:
          server.send(200, "text/plain", "No update available.");
          break;
        case HTTP_UPDATE_OK:
          server.send(200, "text/plain", "Updating firmware, please wait...");
          ESP.restart();
          break;
        default:
          server.send(200, "text/plan", "Something else happened: " + ret);
          break;
      }
    });
    server.on("/reset", []() {
      server.send(200, "text/plain", "See ya later!");
      resetWifiSettings();
    });
    server.onNotFound([]() {
      server.send(404, "text/plain", "404");
    });
    server.on("/on", []() {
      Soulmate.turnOn();
      server.send(200, "text/plain", "on");
    });
    server.on("/off", []() {
      Soulmate.turnOff();
      server.send(200, "text/plain", "off");
    });

    server.on("/ota", HTTP_POST, [&](){
      if (Update.hasError()) {
        server.send(200, F("text/html"), String(F("Update error: ")));
        // server.send(200, F("text/html"), String(F("Update error: ")) + _updaterError);
      } else {
        server.client().setNoDelay(true);
        server.send_P(200, PSTR("text/html"), "OK");
        delay(100);
        server.client().stop();
        ESP.restart();
      }
    }, [&](){
      // handler for the file upload, get's the sketch bytes, and writes
      // them through the Update object
      HTTPUpload& upload = server.upload();
      bool _serial_output = true;
      String _updaterError;

      if (upload.status == UPLOAD_FILE_START) {
        _updaterError = String();

        Serial.setDebugOutput(true);

        WiFiUDP::stopAll();
        Serial.printf("Update: %s\n", upload.filename.c_str());
        uint32_t maxSketchSpace = (ESP.getFreeSketchSpace() - 0x1000) & 0xFFFFF000;
        if (!Update.begin(maxSketchSpace)) {  //start with max available size
          // _setUpdaterError();
        }
      } else if (upload.status == UPLOAD_FILE_WRITE && !_updaterError.length()) {
        Serial.printf(".");
        if (Update.write(upload.buf, upload.currentSize) != upload.currentSize) {
          // _setUpdaterError();
        }
      } else if (upload.status == UPLOAD_FILE_END && !_updaterError.length()) {
        if (Update.end(true)) { //true to set the size to the current progres s
          Serial.printf("Update Success: %u\nRebooting...\n", upload.totalSize);
        } else {
          // _setUpdaterError();
        }
        Serial.setDebugOutput(false);
      } else if (upload.status == UPLOAD_FILE_ABORTED) {
        Update.end();
        Serial.println("Update was aborted");
      }
      delay(0);
    });

    // HomeBridge
    server.on("/homebridge/brightness", handleHomekitBrightness);
    server.on("/homebridge/on", []() {
      Soulmate.turnOn();
      server.send(200, "text/plain", "on");
    });
    server.on("/homebridge/off", []() {
      Soulmate.turnOff();
      server.send(200, "text/plain", "off");
    });

    server.begin();
    Serial.println("Soulmate HTTP server started");
  }

  void setup(void) {
    WiFi.setSleepMode(WIFI_NONE_SLEEP);

    // #ifndef SKIP_BLUETOOTH
    //   Soulmate.StartBluetooth();
    // #endif

    wifiManager.setConnectionWaitCallback([](void) {
      Soulmate.connecting();
    });

    // TODO(elliott): determine wehther we need this if websocket / MDNS are already started
    wifiManager.setSaveConfigCallback([](void) {
      Serial.println("Clearing WIFI mode and going to STA");
      WiFi.mode(WIFI_STA);
      WiFi.softAPdisconnect(false);
      WiFi.enableAP(false);
      delay(200);
      startMDNS();
      webSocket.begin();
      webSocket.onEvent(webSocketEvent);

      // Soulmate.StopBluetooth();
    });

    wifiManager.setRemoveDuplicateAPs(true);

    wifiManager.setConfigPortalBlocking(false);
    // 60 second config portal timeout -
    // TODO(elliott): I don't know if we need this when it's non-blocking
    wifiManager.setConfigPortalTimeout(60);

    // Connection timeout for Wi-Fi (loading pattern plays)
    wifiManager.setConnectTimeout(20);

    // Set the AP name for configuration
    if (wifiManager.autoConnect("Soulmate Config")) {
      Serial.println("Auto-connected. Starting MDNS and webserver");
      startMDNS();
      webSocket.begin();
      webSocket.onEvent(webSocketEvent);
      setupServer();

      // Soulmate.StopBluetooth();
    } else {
      Serial.println("Didn't auto-connect");
      // #ifndef SKIP_BLUETOOTH
      //   Soulmate.StartBluetooth();
      // #endif
    }

    delay(200);
  }

  void loop() {
    // We wait a few seconds here to turn off AP_STA mode
    // otherwise there's a crash for some reason.
    EVERY_N_SECONDS(2) {
      if (WiFi.getMode() != WIFI_STA && WiFi.status() == WL_CONNECTED) {
        WiFi.enableAP(false);
      }
    }

    webSocket.loop();
    wifiManager.process();
    EVERY_N_SECONDS(5) {
      bool pingResult = webSocket.broadcastPing();
      if (!pingResult) {
        Serial.println("No ping result, resetting websockets and restarting server");
        webSocket.disconnect();
        server.stop();
        server.begin();
      }
    }

    EVERY_N_SECONDS(30) {
      if (WiFi.status() != WL_CONNECTED) {
        Serial.println("Not connected... retrying connection");
        wifiManager.autoConnect("Soulmate Config");
      }
    }

    // This used to send out updates, but sometimes it'd hang
    // EVERY_N_SECONDS(20) {
      // updateWifiClients();
    // }
    server.handleClient();
  }
}

void SoulmateLibrary::WifiLoop() {
  Wifi::loop();
}

void SoulmateLibrary::WifiSetup() {
  Wifi::setup();
}

void SoulmateLibrary::updateWifiClients() {
  Wifi::updateWifiClients();
}

void SoulmateLibrary::disconnectWiFi() {
  Serial.println("TODO");
}

void SoulmateLibrary::connectTo(const char* ssid, const char* pass) {
  int _connectTimeout = 10000;
  WiFi.persistent(false);
  WiFi.mode(WIFI_OFF);   // this is a temporary line, to be removed after SDK update to 1.5.4
  WiFi.mode(WIFI_STA);
  WiFi.persistent(true);
  WiFi.begin(ssid, pass);

  unsigned long start = millis();
  boolean keepConnecting = true;
  uint8_t status;
  while (keepConnecting) {
    status = WiFi.status();
    if (millis() > start + _connectTimeout) {
      keepConnecting = false;
      Serial.println("Connection timed out");
    }
    if (status == WL_CONNECTED || status == WL_CONNECT_FAILED) {
      keepConnecting = false;
    }
    delay(100);
  }

  if (status == WL_CONNECTED) {
    // delay(1000);
    ESP.restart();
  }
}

String SoulmateLibrary::ip() {
  return WiFi.localIP().toString();
}

bool SoulmateLibrary::wifiConnected() {
  return WiFi.status() == WL_CONNECTED;
}

#endif
#endif  // BUILDER_LIBRARIES_SOULMATE_ESP8266_WIFI_H_


  // Used by wifi.h to show pattern while connecting
  void connecting() {
    adjustBrightness();
    routines[currentRoutine]();
    #ifndef ESP32
      FastLED.show();
    #endif
  }